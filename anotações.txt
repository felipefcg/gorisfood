* Utilizar Anotação personalidada para qualificador de injeção de dependencia (Bean's)
	Ex: 
		-- Criação da minha anotação
		@Retention(RUNTIME)
		@Qualifier
		public @interface TipoDoNotificador {
			NivelUrgencia value();
		}
		
		-- Classe utilizando a anotação, no lugar do @Qualifier(...)
		@TipoDoNotificador(NivelUrgencia.SEM_URGENCIA)
		@Component
		public class NotificadorEmail implements Notificador {
	
* Utilizar init e destroy no ciclo de vida do Bean, seja na anotação @Bean ou na própria classe com @PostConstruct e @PreDestroy
	- @Bean(initMethod = "init", destroyMethod = "destroy");
	- @PostConstruct public void init() {...} / @PreDestroy public void destroy() {...}
	
* Events no Spring (https://www.baeldung.com/spring-events)
	- Injetar na sua classe "SERVICE" a class "ApplicationEventPublisher"
	- Para disparar o evento chamar o método "eventPublisher.publishEvent(new ClienteNotificacaoPublisher(cliente))"
	- Criar a sua classe de publicação (Publisher) de evento "ClienteNotificacaoPublisher", nesse caso recebe um "cliente"
		public class ClienteNotificacaoPublisher {
			private final Cliente cliente;
		}
	- Criar a(s) classe(s) que vão escutar o evento (Listeners) e o método que vai tratar o evento anotado com EventListener
		@Component
		public class NotificacaoClienteService {
			
			@TipoDoNotificador(NivelUrgencia.SEM_URGENCIA)
			@Autowired
			private Notificador notificador;
			
			@EventListener
			public void notificarCliente(ClienteNotificacaoPublisher event) {
				System.out.println("Notificando o cliente " + event.getCliente().getNome());
				notificador.notificar(event.getCliente(), "Seu cadastro no sistema está ativo!");
			}
		}
	- A forma configurada acima cria o evento de forma sincrona (default do spring)
	
	
* Retornar XML na resposta da requisição
	- Para permitir retornar XML deve ser incluido no POM a dependencia do Jackson-XML, para permitir o parse do objeto
		<dependency>
		  <groupId>com.fasterxml.jackson.dataformat</groupId>
		  <artifactId>jackson-dataformat-xml</artifactId>
		</dependency>
		
* Anotações para alterar informações no JSON e/ou XML
	- @JsonRootName("gastronomia"): Anota a classe para definir o nome do objeto no XML/JSON
	- @JsonIgnore: Anota o atributo da classe para que o mesmo não seja apresentado no XML/JSON
	- @JsonProperty("titulo"): Anota o atributo para mudar o nome do atributo no XML/JSON
	- @JacksonXmlRootElement(localName = "cozinhas") ou @JsonRootName(value = "cozinhas"): para classe Wrapper que vai ser o objeto Root do XML
	- @JsonProperty("cozinha") ou @JacksonXmlProperty(localName = "cozinhaX"): Vai dar o nome dos elementos da lista
	- @JacksonXmlElementWrapper(useWrapping = false): Remove a TAG que encapsula os objetos da lista
	
	EX: @JacksonXmlRootElement(localName = "cozinhas")
		//@JsonRootName(value = "cozinhas")
		@Data
		public class CozinhaXmlWrapper {

			@NonNull
			@JsonProperty("cozinha")
		//	@JacksonXmlProperty(localName = "cozinhaX")
			@JacksonXmlElementWrapper(useWrapping = false)
			private List<Cozinha> cozinhas;
		}
		
	- @JsonIgnoreProperties: Ignora o(s) atributo(s) do objeto
		EX: Ignora o atributo Id que tem em Cozinha
			@JsonIgnoreProperties("id")
			private Cozinha cozinha;
		
* Métodos HTTP
	- GET: consultar um recurso ou uma lista
	- POST: criar um recurso
	- PUT: Atualizar ou criar um recurso.
		- Criar: PUT /cozinhas/11 -> criar o recurso com o ID 11, ou se ja existir atualizar. 
				 Raramente é utilizado para essa finalidade de criação
		- Atualizar: Atualiza todo todo o recurso. 
					 Se na requisição foi passado apenas um atributo do recurso, irá atualizar o atributo com o valor informado e os demais ficarão em branco.
	- PATCH: Atualização parcial do recurso, apenas atualiza os dados informados
	- DELETE: Remove um recurso (seja físicamente ou logicamente)
	- HEAD: Pareceido com o GET, porém não retorna um corpo. 
			Utilizado apenas para buscar os cabeçalhos de um recurso
	- OPTIONS: retorna os métodos HTTP aceitos por um recurso
		
* Utilizar o BeanUtils para copiar valores de um objeto 1 para o objeto 2 desde que sejam a mesma classe.
	- org.springframework.beans.BeanUtils.copyProperties(source, target, "propriedadeIgnoradaNaCopia");
	- Essa situação não é um mapper
	
* Ao tentar fazermos um delete de um recurso (Ex: cozinha) que, por exemplo, não pode ser removido por ser FK para outro recurso (cozinha é FK de restaurantes),
podemos retornar o HTTP STATUS 409 (CONFLICT)

* Utilizando Exctions do Srpring
	- org.springframework.dao.DataIntegrityViolationException
	- org.springframework.dao.EmptyResultDataAccessException
	
* Utilizando NAMED QUERY: 
	- É possível utilizar Named Query utilizam a anotação @NamedQuery em cima do método, e dessa forma colocar a query na própria anotação ou no 
arquivo /META-INF/orm.xml
	- Ou nomeando a query no arquivo /META-INF/orm.xml com NomeEntidadeDominio.nomeDoMetodoDeQuery
	Ex conteudo do arquivo:
		<?xml version="1.0" encoding="UTF-8"?>
		<entity-mappings 
			xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd"
			version="2.2">

			<named-query name="Restaurante.consultaPorNomeETaxaFrete">
				<query>
					from Restaurante 
					where nome like concat('%',:nome,'%') 
					and taxaFrete between :taxaInicio and :taxaFim
				</query>
			</named-query>
		</entity-mappings>
	- o arquivo /META-INF/orm.xml geralmente é utilizado quando temos queries muito grande para deixar nas anotações em cima da assinatura dos métodos
	- Para mapear mais de um arquivo XML, afim de separar as queries e deixar os arquivos menores devemo declarar no application.properties
		EX: spring.jpa.mapping-resources=META-INF/orm-restaurantes.xml,META-INF/orm-clientes.xml
		
* é possivel utilizar classes Repository customizadas, desde que ela tenha o msm nome da interface com o sufixo Impl e a interface tenha a assinatura do método
da implementação
	Ex: RestauranteRepositoryImpl e RestauranteRepository
	Afim de melhorar a validação em tempo de desenvolvimento podemos criar uma Interface nova onde a Implementação implementa a interface customizada e a 
interface Repository extende a customizada.
	Ex: 
		- public class RestauranteRepositoryImpl implements RestauranteRepositoryCustom {...}
		- public interface RestauranteRepository extends RestauranteRepositoryCustom, JpaRepository<Restaurante, Long> {...}
		
* Centralizar a Specification dentro do RepositoryImpl e injetar a própria interface Repository	dentro da Implementação, para isso precisamo anotar a injeção 
de dependencia com @Lazy para que essa dependencia seja carregado apenas no momento de uso, evitando assim referência circular.
 Ex: 
	@Repository
	public class RestauranteRepositoryImpl implements RestauranteRepositoryCustom {
	
		@Autowired
		@Lazy
		private RestauranteRepository repository;
		
		//... demais atributos e métodos ...
	}
	
* Criar um JPA Repository Customizado para implementar métodos de busca repetitivos que podem servir para todas os nosso repositórios
	Para isso precisamos:
		1 - Criar interface que extende JpaRepository: public interface CustomJpaRepository<T, ID> extends JpaRepository<T, ID> {...}
		2 - Anotar a interface com @NoRepositoryBean
		3 - Criar classe de implementação que implementa a nova interface e extende SimpleJpaRepository: 
			public class CustomJpaRepositoryImpl<T, ID> extends SimpleJpaRepository<T, ID> implements CustomJpaRepository<T, ID> {
				private EntityManager em;
					
				public CustomJpaRepositoryImpl(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {
					super(entityInformation, entityManager);
					this.em = entityManager;
				}
				
				//... Métodos CRUD ...
			}
		4 - Adicionar na classe de start da aplicação a anotação @EnableJpaRepositories: @EnableJpaRepositories(repositoryBaseClass = CustomJpaRepositoryImpl.class)
		5 - Extender no seu Repository a interface customizada ao invés de JpaRepository: 
			public interface RestauranteRepository extends CustomJpaRepository<Restaurante, Long> {}
		
* Campos DATA_CRIACAO e DATA_ATUALIZACAO: Geralmente nos sistemas nós colocamos nas tabelas os campos de data criacao e atualização e ficamos "controlando" 
a atualizção dessas datas, porém temos como passar esse boilerplate para o Hibernate com as anotações:
	- @CreationTimestamp
	- @UpdateTimestamp
Onde ele automaticamente gerencia esse controle, sendo q no CreationTimestamp ele insere apenas na criação do registro no banco e o UpdateTimestamp em todo 
momento	que vamos salvar o registro.

* Hibernate: Problema do N+1: Umas das formas de resolver esse problema é utilizar o JOIN FETCH no JPQL
	EX: 
		@Query("from Restaurante r JOIN FETCH r.cozinha left JOIN FETCH r.formasPagamento")
		List<Restaurante> findAll(); 
	
* LazyInitializationException – O que é e a melhor maneira de corrigi-lo: https://thorben-janssen.com/lazyinitializationexception/	

* FLYWAY
	* É possível mudar a localização dos arquivos do Flyway utilizando a propriedade spring.flyway.locations
	EX: spring.flyway.locations=classpath:db/migration,classpath:db/testdata
	
	
* @ResponseStatus: além de definir o HTTP STATUS do método do Controller, também é possível anotar as Exceptions da sua aplicação
	para quando ocorrer a Exceção e ela não for tratada no fluxo da aplicação o Spring Boot retorna a exceção na resposta com 
	o HTTP STATUS definido na anotação.
	OBS: Essa solução retorna o body no formato padrão de erro do Spring, sem customização do desenvolvedor
		
* ResponseStatusException: é uma exceção criao pelo Spring aonde você informa o HTTP STATUS de retorno e mensagem do erro.	
	OBS: Essa solução retorna o body no formato padrão de erro do Spring, sem customização do desenvolvedor
	OBS2: Essa classe tem as subclasses:
			* MethodNotAllowedException
			* NotAcceptableStatusException
			* ServerErrorException
			* ServerWebInputException
			* UnsupportedMediaTypeStatusException
	Ex: 
		@DeleteMapping("{id}")
		public ResponseEntity remover(@PathVariable Long id) {
			try {
				service.remover(id);
				return ResponseEntity.noContent().build();

			} catch (EntidadeNaoEncontradaException e) {
				//return ResponseEntity.notFound().build();
				throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
				
			} catch (EntidadeEmUsoExcpetion e) {
				//return ResponseEntity.status(HttpStatus.CONFLICT).build();
				throw new ResponseStatusException(HttpStatus.CONFLICT, e.getMessage());
				
			}
		}
		
** ESPECIFICAÇÕES PARA RETORNO DE ERROS 
	* RFC 7807: https://www.rfc-editor.org/rfc/rfc7807
	* JSON API: https://jsonapi.org/format/#error-objects / https://jsonapi.org/examples/#error-objects
	* VND.ERROR: https://github.com/blongden/vnd.error
	
* Forçar jackson a falhar quando é enviado um atributo que não faz parte do body/DTO e/ou que esta anotado com @JsonIgnore
	* Por properties
	- spring.jackson.deserialization.fail-on-unknown-properties = true
	- spring.jackson.deserialization.fail-on-ignored-properties = true
	
	* Programaticamente
	- mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true);
	- mapper.configure(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES, true);
	
** Habilitar Spring Boot para customizar erro de URL inexistente (não mapeada) no Spring
	* Deve setar as propriedades 
		- spring.mvc.throw-exception-if-no-handler-found=true
		- spring.web.resources.add-mappings=false
	* Criar uma classe Handler para tratar os erros anotada com @RestControllerAdvice e extendendo ResponseEntityExceptionHandler
	 - sobrescrever o método handleNoHandlerFoundException