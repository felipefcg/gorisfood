* Utilizar Anotação personalidada para qualificador de injeção de dependencia (Bean's)
	Ex: 
		-- Criação da minha anotação
		@Retention(RUNTIME)
		@Qualifier
		public @interface TipoDoNotificador {
			NivelUrgencia value();
		}
		
		-- Classe utilizando a anotação, no lugar do @Qualifier(...)
		@TipoDoNotificador(NivelUrgencia.SEM_URGENCIA)
		@Component
		public class NotificadorEmail implements Notificador {
	
* Utilizar init e destroy no ciclo de vida do Bean, seja na anotação @Bean ou na própria classe com @PostConstruct e @PreDestroy
	- @Bean(initMethod = "init", destroyMethod = "destroy");
	- @PostConstruct public void init() {...} / @PreDestroy public void destroy() {...}
	
* Events no Spring (https://www.baeldung.com/spring-events)
	- Injetar na sua classe "SERVICE" a class "ApplicationEventPublisher"
	- Para disparar o evento chamar o método "eventPublisher.publishEvent(new ClienteNotificacaoPublisher(cliente))"
	- Criar a sua classe de publicação (Publisher) de evento "ClienteNotificacaoPublisher", nesse caso recebe um "cliente"
		public class ClienteNotificacaoPublisher {
			private final Cliente cliente;
		}
	- Criar a(s) classe(s) que vão escutar o evento (Listeners) e o método que vai tratar o evento anotado com EventListener
		@Component
		public class NotificacaoClienteService {
			
			@TipoDoNotificador(NivelUrgencia.SEM_URGENCIA)
			@Autowired
			private Notificador notificador;
			
			@EventListener
			public void notificarCliente(ClienteNotificacaoPublisher event) {
				System.out.println("Notificando o cliente " + event.getCliente().getNome());
				notificador.notificar(event.getCliente(), "Seu cadastro no sistema está ativo!");
			}
		}
	- A forma configurada acima cria o evento de forma sincrona (default do spring)
	
	
* Retornar XML na resposta da requisição
	- Para permitir retornar XML deve ser incluido no POM a dependencia do Jackson-XML, para permitir o parse do objeto
		<dependency>
		  <groupId>com.fasterxml.jackson.dataformat</groupId>
		  <artifactId>jackson-dataformat-xml</artifactId>
		</dependency>
		
* Anotações para alterar informações no JSON e/ou XML
	- @JsonRootName("gastronomia"): Anota a classe para definir o nome do objeto no XML/JSON
	- @JsonIgnore: Anota o atributo da classe para que o mesmo não seja apresentado no XML/JSON
	- @JsonProperty("titulo"): Anota o atributo para mudar o nome do atributo no XML/JSON
	- @JacksonXmlRootElement(localName = "cozinhas"): para classe Wrapper que vai ser o objeto Root do XML
	- @JsonProperty("cozinha") ou @JacksonXmlProperty(localName = "cozinhaX"): Vai dar o nome dos elementos da lista
	- @JacksonXmlElementWrapper(useWrapping = false): Remove a TAG que encapsula os objetos da lista
	
	EX: @JacksonXmlRootElement(localName = "cozinhas")
		@Data
		public class CozinhaXmlWrapper {

			@NonNull
			@JsonProperty("cozinha")
		//	@JacksonXmlProperty(localName = "cozinhaX")
			@JacksonXmlElementWrapper(useWrapping = false)
			private List<Cozinha> cozinhas;
		}
	